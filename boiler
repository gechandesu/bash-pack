#!/usr/bin/env bash

# * Boiler. Bash boilerplate.
#
# Copyright (c) 2021 ge <me@nixhacks.net>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

boiler_version=0.2.2

boiler_help() {
	cat <<- EOF
	Bash boilerplate.

	Usage: boiler [-v|--version] [-h|--help] command [<options>..] [<arguments>..]

	Options:
	    -v, --version       print version and exit.
	    -h, --help          print this help message and exit.

	Commands:
	    project  <name> [<options>..]   start new project with <name>.
	    function <name> [<options>..]   print function template.
	    file     <name> [<options>..]   create file from template.
	    license  <name> [<options>..]   print license text.

	Command options:
	    project
	        -l, --license=<license>     license, see 'boiler license --list'
	        -a, --author=<author>       name of author.
	        --no-dir                    do not make project's directory.
	    function
	        -l, --list      list available function templates.
	        -c, --no-color  do not highlight output.
	    file
	        -l, --list      list available file templates.
	    licanse
	        -l, --list      list available license texts.
	        -a, --author    add author to license text, not affects with '--save'
	        -s, --save      download license text and save as COPYING

	Run 'function|file|license' without any arguments to list available items,
	same as '--list' option.
	EOF
    exit 0
}

boiler_opts() {
    # GNU-style CLI options parser.
    #
    # Parse --opt VAL and --opt=VAL options.
    # Requires 2 arguments: $1, $2.
    # Returns:
    #   $opt - option name.
    #   $arg - option's value.
    #   $sft - value for shift.
    if [[ "$1" =~ .+=.+ ]]; then
        opt="${1%%=*}"; arg="${1#*=}"; sft=1
    elif [[ ! "$1" =~ .+=$ ]] && \
         [ "$2" ] && [ "${2:0:1}" != '-' ]
    then
        opt="$1"; arg="$2"; sft=2
    else
        opt="$1"
        if [[ "$1" =~ .+=$ ]]; then opt="${1:0: -1}"; fi
        echo "${0##*/}: missing argument for: $opt"
    fi
}

boiler_version() {
    echo boiler $boiler_version
    exit 1
}

boiler_project() {
    while (( "$#" )); do
        case "$1" in
            -l|--license) boiler_opts "$1" "$2"
                BOILERLICENSE="$arg"; shift $sft;;
            -a|--author)  boiler_opts "$1" "$2"
                BOILERAUTHOR="$arg"; shift $sft;;
            --no-dir)   __no_prj_dir=1; shift;;
            -h|--help) boiler_help;;
            -*) echo "${0##*/}: $1: bad option" >&2; exit 1;;
            *)  BOILERPROJECT="$1"; shift;;
        esac
    done

    local _project="$BOILERPROJECT"
    local _license="$BOILERLICENSE"
    local _author="$BOILERAUTHOR"

    [[ "$_project" != '' ]] || {
        echo No project name specified >&2; exit 1
    }

    if [ "$__no_prj_dir" ]; then
        local _script="${PWD}/${_project}"
    else
        mkdir -p "${PWD}/${_project}"
        local _script="${PWD}/${_project}/${_project}"
    fi
    echo '#!/usr/bin/env bash' > "$_script"
    [ "$_license" ] && boiler_license "$_license" >> "$_script"
    chmod +x "$_script"
    echo "$_script"
}

boiler_function() {
    [[ "$@" ]] || boiler_function_list
    while (( "$#" )); do
    case "${1,,}" in
        opts|editor|yesno|anykey|iniparser|random|writelog|python_version)
            __func="${1,,}"; shift;;
        -l|--list)      __listfunc=1; shift;;
        -c|--no-color)  __nocolor=1; shift;;
        -h|--help) boiler_help;;
        *) echo "${0##*/}: $1: bad function" >&2; exit 1;;
    esac
    done

    [ "$__listfunc" ] && boiler_function_list

    if hash highlight > /dev/null; then
        [ "$__nocolor" ] || hl=' | highlight -O ansi -S bash'
    fi

    eval "boiler_function::$__func $hl"
}

boiler_function_list() {
    echo 'opts              GNU-style argument parser.'
    echo 'editor            fetch or select EDITOR and print it.'
    echo 'yesno             Yes/No interactive dialog'
    echo 'anykey            'Press any key' interactive dialog.'
    echo 'iniparser         .ini config file parser.'
    echo 'random            random string generator.'
    echo 'writelog          simple logger.'
    echo 'python_version    detect Python interpreter version.'
    exit 0
}

boiler_file() {
    [[ "$@" ]] || boiler_file_list
    while (( "$#" )); do
    case "${1,,}" in
        completion) __file="${1,,}"; shift;;
        -l|--list)  __listfiles=1; shift;;
        -h|--help) boiler_help;;
        *) echo "${0##*/}: $1: bad filename" >&2; exit 1;;
    esac
    done

    [ "$__listfiles" ] && boiler_file_list

    eval boiler_file::$__file > $PWD/$__file && \
    echo $PWD/$__file
}

boiler_file_list() {
    echo 'completion        Bash autocompletion script.'
    exit 0
}

boiler_license() {
    [[ "$@" ]] || boiler_license_list
    while (( "$#" )); do
    case "${1,,}" in
        gplv3|mit|unlicense) __license="${1,,}"; shift;;
        -l|--list)  __listlicenses=1; shift;;
        -a|--author) boiler_opts "$1" "$2"
                BOILERAUTHOR="$arg"; shift $sft;;
        -s|--save)  __save=1; shift;;
        -h|--help) boiler_help;;
        *) echo "${0##*/}: $1: bad license" >&2; exit 1;;
    esac
    done

    [ "$__listlicenses" ] && boiler_license_list

    if [ "$__save" ]; then
        boiler_license_download "$__license"
    fi

    eval boiler_license::$__license
}

boiler_license_list() {
    echo 'mit               MIT License <https://mit-license.org/>'
    echo 'gplv3             GNU GPLv3 <https://www.gnu.org/licenses/>'
    echo 'unlicense         The Unlicense <https://unlicense.org/>'
    exit 0
}

boiler_license_download() {
    local url
    local copying="${PWD}/COPYING"
    case "$1" in
        mit)        url='https://mit-license.org/license.txt';;
        gplv3)      url='https://www.gnu.org/licenses/gpl-3.0.txt';;
        unlicense)  url='https://unlicense.org/UNLICENSE';;
    esac

    if curl --silent --connect-timeout 3 "$url" -o "$copying"; then
        [ -f "$copying" ] && echo -e "$copying\n"
        echo "Don't forget to add the year and author's name to the COPYING file!"
    else
        echo "Cannot download license text. Please, refer to <https://opensource.org/licenses/>"
    fi
    exit "$?"
}

#
# * BOILERPLATES
#

boiler_function::opts() {
	cat <<- EOF
	opts() {
	    # GNU-style CLI options parser.
	    #
	    # Parse --opt VAL and --opt=VAL options.
	    # Requires 2 arguments: \$1, \$2.
	    # Returns:
	    #   \$opt - option name.
	    #   \$arg - option value.
	    #   \$sft - value for shift.

	    if [[ "\$1" =~ .+=.+ ]]; then
	        opt="\${1%%=*}"; arg="\${1#*=}"; sft=1
	    elif [[ ! "\$1" =~ .+=$ ]] && \\
	         [ "\$2" ] && [ "\${2:0:1}" != "-" ]
	    then
	        opt="\$1"; arg="\$2"; sft=2
	    else
	        opt="\$1"
	        if [[ "\$1" =~ .+=$ ]]; then opt="\${1:0: -1}"; fi
	        echo "Missing argument for: \$opt" >& /dev/null; exit 1
	    fi
	}
	EOF
}

boiler_function::editor() {
	cat <<- EOF
	editor() {
	    # Print default editor.
	    #
	    # Usage: eval \`editor\` file
	    _get_selected_editor() {
	        source \$HOME/.selected_editor
	        echo \$SELECTED_EDITOR
	    }
	    if [ "\$EDITOR" ]; then
	        echo \$EDITOR
	    elif [ -f \$HOME/.selected_editor ]; then
	        _get_selected_editor
	    elif hash /usr/bin/select-editor > /dev/null; then
	        select-editor; _get_selected_editor
	    elif hash /usr/bin/editor > /dev/null; then
	        echo /usr/bin/editor
	    else
	        echo /usr/bin/vi
	    fi
	}
	EOF
}

boiler_function::yesno() {
	cat <<- EOF
	yesno() {
	    # Yes/No interactive dialog.
	    #
	    # Usage: if yesno 'Question'; then ...
	    local answer=
	    [ "\$ASSUME_YES" ] && return 0

	    while [ ! "\$answer" ]; do
	        echo -en "\$@ (y/n) "
	        read -r reply
	        case "\${reply,,}" in
	            y|yes)  answer=0;;
	            n|no)   answer=1;;
	            *)      echo "Please, answer y or n";;
	        esac
	    done
	    return "\$answer"
	}
	EOF
}

boiler_function::anykey() {
	cat <<- EOF
	anykey() {
	    read -n 1 -s -r -p "Press any key to continue..."
	}
	EOF
}

boiler_function::iniparser() {
	cat <<- EOF
	iniparser() {
	    # Parse simple .ini-style config file
	    #
	    # Usage: iniparser file

	    [ ! -f "\$1" ] && { echo "\$0: \$1: no such file"; exit 1; }

	    local config="\$( \\
	        sed 's/[[:space:]]\+=[[:space:]]\+/=/g;
	            s/#.*//g;/^=/d;/^$/d' <(cat "\$1" | grep = ) |
	        while read -r LN; do echo \$(printf '%q' "\$LN"); done)"

	    eval "\$config"
	}
	EOF
}

boiler_function::random() {
	cat <<- EOF
	random() {
	    # Generate random string
	    #
	    # Usage: line_len=32; random \$line_len

	    local dict=({a..z} {A..Z} {0..9} - _)
	    local range=\$(eval "echo {1..\$1}")
	    for i in \$range; do echo -n \${dict[\$RANDOM%64]}; done
	}
	EOF
}

boiler_function::writelog() {
	cat <<- EOF
	writelog() {
	    # Write message to logfile
	    #
	    # Usage: writelog [-p-] [<message>]
	    #
	    # Can read from STDIN. Removes ANSI escape codes from log message.
	    # Echo message to STDOUT with '--print' option.

	    local message print logfile=log.txt

	    # If no arguments passed OR '0' descriptor is open, then read from descriptor.
	    # If no arguments AND '0' descriptor is closed, then 'message' will not be set.
	    [[ "\$@" || -t 0 ]] || message="\$(cat <&0)"

	    while (( "\$#" )); do
	    case "\$1" in
	        -p|--print) print=1; shift;;
	        -) message="\$(cat <&0)"; shift "\$#";;
	        *) message="\$@"; shift "\$#";;
	    esac
	    done
	    [[ "\$print" == '1' ]] && echo "\$message"
	    while read line; do
	        printf '%s [%s] %s\\n' "\$(date +'%d %b %Y %H:%M:%S %z')" "\$0" "\$line" >> "\$logfile"
	    done <<< "\$(sed -r 's/\\x1B\[(([0-9]+)(;[0-9]+)*)?[m,K,H,f,J]//g' <<< "\$message")"
	}
	EOF
}

boiler_function::python_version() {
	cat <<- EOF
	python_version() {
	    # Get Python interpreter version in format: major.minor.micro, e.g. 3.10.2
	    # Works with Python 2 too.
	    #
	    # Usage: python_version [<path to interpreter>]

	    local python_bin=
	    if [ "\$1" ]; then python_bin="\$1"; else python_bin="python"; fi
	    "\$python_bin" -c "import sys; v=sys.version_info; print(str(v.major) + '.' + str(v.minor) + '.' + str(v.micro))"
	}
	EOF
}

boiler_file::completion() {
	cat <<- EOF
	#!/usr/bin/bash

	_completion() {
	    local cur prev
	    cur=\${COMP_WORDS[COMP_CWORD]}
	    prev=\${COMP_WORDS[COMP_CWORD-1]}

	    case \${COMP_CWORD} in
	        1) # Firs level commands
	            COMPREPLY=(\$(compgen -W "--help --version" -- \${cur}));;
	        2) # Subcommands
	            case \${prev} in
	                cmd) COMPREPLY=();;
	                *)  COMPREPLY=();;
	            esac;;
	        *) # Subcommand options completion
	            case \${COMP_WORDS[2]} in
	                *) COMPREPLY=();;
	            esac;;
	        *) COMPREPLY=();;
	    esac
	}

	complete -F _completion myscript
	EOF
}

boiler_license::gplv3() {
    [ "$BOILERAUTHOR" ] || BOILERAUTHOR='<name of author>'
	cat <<- EOF

	# <one line to give the program's name and a brief idea of what it does.>
	# Copyright (c) $(date +%Y) $BOILERAUTHOR
	#
	# This program is free software: you can redistribute it and/or modify
	# it under the terms of the GNU General Public License as published by
	# the Free Software Foundation, either version 3 of the License, or
	# (at your option) any later version.
	#
	# This program is distributed in the hope that it will be useful,
	# but WITHOUT ANY WARRANTY; without even the implied warranty of
	# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	# GNU General Public License for more details.
	#
	# You should have received a copy of the GNU General Public License
	# along with this program.  If not, see <https://www.gnu.org/licenses/>.

	EOF
}

boiler_license::mit() {
    [ "$BOILERAUTHOR" ] || BOILERAUTHOR='<name of author>'
	cat <<- EOF

	# Copyright (c) $(date +%Y) $BOILERAUTHOR
	#
	# Permission is hereby granted, free of charge, to any person obtaining
	# a copy of this software and associated documentation files (the
	# "Software"), to deal in the Software without restriction, including
	# without limitation the rights to use, copy, modify, merge, publish,
	# distribute, sublicense, and/or sell copies of the Software, and to
	# permit persons to whom the Software is furnished to do so, subject to
	# the following conditions:
	#
	# The above copyright notice and this permission notice shall be
	# included in all copies or substantial portions of the Software.
	#
	# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
	# LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
	# OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
	# WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

	EOF
}

boiler_license::unlicense() {
	cat <<- EOF

	# This is free and unencumbered software released into the public domain.
	#
	# Anyone is free to copy, modify, publish, use, compile, sell, or
	# distribute this software, either in source code form or as a compiled
	# binary, for any purpose, commercial or non-commercial, and by any
	# means.
	#
	# In jurisdictions that recognize copyright laws, the author or authors
	# of this software dedicate any and all copyright interest in the
	# software to the public domain. We make this dedication for the benefit
	# of the public at large and to the detriment of our heirs and
	# successors. We intend this dedication to be an overt act of
	# relinquishment in perpetuity of all present and future rights to this
	# software under copyright law.
	#
	# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
	# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
	# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
	# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
	# OTHER DEALINGS IN THE SOFTWARE.
	#
	# For more information, please refer to <http://unlicense.org/>

	EOF
}

[[ "$@" ]] || boiler_help
while (( "$#" )); do
    case "$1" in
        -v|--version)   boiler_version;;
        -h|--help)      boiler_help;;
        project)        shift; boiler_project   "$@"; shift "$#";;
        func|function)  shift; boiler_function  "$@"; shift "$#";;
        file)           shift; boiler_file      "$@"; shift "$#";;
        license)        shift; boiler_license   "$@"; shift "$#";;
        *)  echo "${0##*/}: $1: bad argument" >&2; exit 1;;
    esac
done
